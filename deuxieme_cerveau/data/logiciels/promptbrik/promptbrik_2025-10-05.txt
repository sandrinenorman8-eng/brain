19:37:16: Ã‰TAPE 1 : CONFIGURATION INITIALE
Objectif : PrÃ©parer la structure du projet et les fichiers de configuration.
TÃ¢ches :

CrÃ©er la structure de dossiers :


1
2
3
project/
â”œâ”€â”€ chrome-extension/
â””â”€â”€ flask-backend/
Dans flask-backend/, gÃ©nÃ©rer :
requirements.txt avec Flask, requests, openai
config.ini.template contenant les champs API_KEY, DEFAULT_MODEL, FALLBACK_MODEL, CACHE_ENABLED, RETRY_ATTEMPTS
CritÃ¨re de validation : Les deux fichiers existent et sont syntaxiquement valides.
Sortie attendue : Liste des chemins crÃ©Ã©s + contenu de config.ini.template.
ğŸ”¹ Ã‰TAPE 2 : DÃ‰VELOPPEMENT DU BACKEND FLASK
Objectif : ImplÃ©menter un serveur Flask local exposant les endpoints requis.
TÃ¢ches :

CrÃ©er flask-backend/app.py avec :
Chargement de config.ini (fallback sur .template)
Cache mÃ©moire response_cache = {}
Fonction call_openrouter_api(prompt) utilisant https://openrouter.ai/api/v1/chat/completions 
Fonction parse_four_versions(response) extrayant JSON, tags, EN, CN
ImplÃ©menter les endpoints :
GET /health
POST /convert â†’ vectorise le prompt
GET /stats, POST /switch-model, GET /backup-zip, GET /open-explorer
GET / â†’ servir index.html
CrÃ©er flask-backend/index.html (interface en franÃ§ais, affichage des 4 sections)
CritÃ¨re de validation : Le serveur dÃ©marre avec python app.py et rÃ©pond Ã  /health.
Sortie attendue : Code complet de app.py + index.html.
ğŸ”¹ Ã‰TAPE 3 : DÃ‰VELOPPEMENT DE Lâ€™EXTENSION CHROME (MANIFEST V3)
Objectif : CrÃ©er une extension fonctionnelle avec menu contextuel et auto-collage.
TÃ¢ches :

GÃ©nÃ©rer chrome-extension/manifest.json (Manifest V3) avec :
Permissions : activeTab, contextMenus, scripting, clipboardWrite, storage
host_permissions: http://127.0.0.1:11000/*
Service worker, content script, popup
ImplÃ©menter :
service_worker.js : gestion du clic droit â†’ appel /convert â†’ auto-paste
content.js : vÃ©rification pÃ©riodique de /health
popup.html + popup.js : affichage du statut serveur
CritÃ¨re de validation : Lâ€™extension se charge dans Chrome en mode dÃ©veloppeur sans erreur.
Sortie attendue : Tous les fichiers de lâ€™extension (manifest.json, *.js, *.html).
ğŸ”¹ Ã‰TAPE 4 : INTÃ‰GRATION ET SÃ‰CURITÃ‰
Objectif : Assurer la sÃ©curitÃ©, la robustesse et la conformitÃ© minimale.
TÃ¢ches :

Dans app.py, forcer app.run(host="127.0.0.1", port=11000) â†’ pas dâ€™exposition rÃ©seau.
Dans service_worker.js, ajouter :
Timeout de 10s sur /convert
Fallback vers presse-papiers si injection Ã©choue
Notification claire si serveur non lancÃ©
Dans content.js, utiliser textContent (pas innerHTML) pour les notifications â†’ Ã©viter XSS.
GÃ©nÃ©rer un README.md avec :
Instructions dâ€™installation
Avertissement : â€œVos prompts sont envoyÃ©s Ã  OpenRouter. Ne soumettez pas de donnÃ©es sensibles.â€
CritÃ¨re de validation : Aucune vulnÃ©rabilitÃ© XSS ou exposition rÃ©seau dÃ©tectable.
Sortie attendue : README.md + snippets de code sÃ©curisÃ©s.
ğŸ”¹ Ã‰TAPE 5 : TESTS ET LIVRAISON
Objectif : Valider le comportement et prÃ©parer le packaging.
TÃ¢ches :

Simuler un flux complet :
Utilisateur sÃ©lectionne â€œBonjour, rÃ©sume ceciâ€ â†’ clic droit â†’ texte vectorisÃ© collÃ©
VÃ©rifier que :
Le cache fonctionne (2e appel = instantanÃ©)
Lâ€™erreur OpenRouter dÃ©clenche le fallback de modÃ¨le
Le collage marche dans <input>, <textarea>, div[contenteditable]
CrÃ©er un script de dÃ©marrage :
run_server.sh (Linux/macOS) : python flask-backend/app.py
run_server.bat (Windows) : idem
CritÃ¨re de validation : Lâ€™ensemble fonctionne sur une machine fraÃ®che avec Python 3.9+.
Sortie attendue : Rapport de test + scripts de dÃ©marrage.Faut que tu arrÃªtes de me donner le. Contenu des fichiers, Ã§a sert Ã  rien. Tu                      fais l'Ã©dition, c'est tout.Ã€ chaque Ã©tape, utilise directement les outils dâ€™Ã©dition de fichiers pour crÃ©er, modifier ou valider le contenu des fichiers spÃ©cifiÃ©s â€” sans fournir de conseils, mais en agissant concrÃ¨tement sur le systÃ¨me de fichiers.
20:00:47: 1. Structure HTML
ğŸ”¹ VÃ©rifications de prÃ©sence

Chaque bouton attendu existe avec le bon id :

refresh-btn

open-panel-btn

open-options-btn

quick-vectorize-btn

convert-btn

copy-btn

close-panel

smart-vectorization-float

save

reset-defaults

Chaque bouton a un texte lisible (emoji + libellÃ© clair).

Chaque bouton contient un aria-label et, si possible, un title explicite.

Les boutons du panneau sont groupÃ©s dans un conteneur .sv-actions avec au moins trois enfants.

ğŸ¨ 2. Styles (CSS)
ğŸ”¹ VÃ©rifications globales

Le fichier buttons.css est chargÃ© dans toutes les vues :

popup.html

panel.html (via @import)

options.html

injectÃ© dans le content_fixed.js (pour le bouton flottant)

Tous les boutons utilisent uniquement des classes CSS (.btn, .sv-btn, etc.)
â†’ aucun style inline ne doit subsister.

Les classes btn-* ou sv-btn-* sont prÃ©sentes :

.btn-primary

.btn-success

.btn-warn

.btn-secondary

.sv-btn-primary

.sv-btn-success

.sv-btn-warn

Les variables CSS (--sv-primary, --sv-success, etc.) sont dÃ©clarÃ©es dans :root.

ğŸ”¹ SpÃ©cifique au bouton flottant

VÃ©rifier la prÃ©sence de .sv-float-btn avec :

position: fixed;

border-radius: 50%;

width et height de 56px

bottom: 20px; right: 20px;

Lâ€™Ã©tat .active applique background: var(--sv-primary) et change lâ€™emoji âœ¨â†’ğŸš€.

ğŸ”¹ Ã‰tats et transitions

Chaque bouton rÃ©agit Ã  :hover et :active :

:hover â†’ translation ou Ã©claircissement

:active â†’ scale(0.97)

Lâ€™Ã©tat :disabled diminue lâ€™opacitÃ© et dÃ©sactive le curseur.

La classe .loading dÃ©clenche lâ€™animation pulse.

âš™ï¸ 3. JavaScript comportemental
ğŸ”¹ VÃ©rification des fonctions globales

Fonctions prÃ©sentes dans buttons.js :

setButtonLoading(btn, text)

restoreButton(btn)

flashButton(btn, color)

showToast(message, type)

Ces fonctions sont accessibles via window.SVButtons.

ğŸ”¹ Logique de clic

Popup

refresh-btn â†’ dÃ©sactivÃ© pendant le â€œCheckâ€, affiche un toast â€œServer healthyâ€.

open-panel-btn â†’ envoie chrome.runtime.sendMessage({action:"openPanel"}).

open-options-btn â†’ ouvre options.html.

Panel

quick-vectorize-btn â†’ active Ã©tat loading puis toast â€œQuick Vectorization Completeâ€.

convert-btn â†’ active Ã©tat loading puis toast â€œConversion Doneâ€.

copy-btn â†’ copie le contenu de #result-content au presse-papiers.

close-panel â†’ masque le conteneur #smart-vectorization-panel.

Floating Button

Au clic : alterne display:block/none sur le panel.

Alterne lâ€™emoji âœ¨â†”ğŸš€.

Active la classe .active.

Options

save â†’ simule sauvegarde (loading + toast â€œPreferences savedâ€).

reset-defaults â†’ simule rÃ©initialisation (loading + toast â€œDefaults restoredâ€).

ğŸ”” 4. Feedback utilisateur

Chaque action visuelle affiche un toast (showToast()) :

type â€œsuccessâ€ â†’ vert

type â€œinfoâ€ â†’ bleu

type â€œwarnâ€ â†’ jaune

type â€œerrorâ€ â†’ rouge

Le toast disparaÃ®t automatiquement aprÃ¨s ~2,5 s.

Aucun alert() ou prompt() ne doit Ãªtre utilisÃ©.

Aucun blocage de lâ€™interface (await bloquant sans animation).

ğŸ§± 5. AccessibilitÃ© & UX

Tous les boutons sont accessibles au clavier (tabindex automatique).

Les boutons ont un focus visible (outline: 2px solid var(--sv-primary);).

Les labels aria-label sont uniques et explicites.

Aucun bouton nâ€™a de rÃ´le visuel sans texte (emoji seul interdit sans aria-label).

Les boutons dÃ©sactivÃ©s doivent Ãªtre ignorÃ©s par la navigation clavier (disabled).

ğŸ” 6. IntÃ©gritÃ© & CohÃ©rence

Aucun bouton nâ€™a de styles inline restants.

Aucun ID dupliquÃ©.

Tous les boutons ont un comportement assignÃ© (aucun orphelin non reliÃ© Ã  un event listener).

Le JS ne lance aucune erreur console lors de clics rÃ©pÃ©tÃ©s.

Le CSS et JS utilisent les mÃªmes noms de classes et dâ€™ID (pas dâ€™incohÃ©rence typographique).

ğŸ§© 7. Injection et runtime

buttons.js est bien injectÃ© :

Dans popup.html

Dans panel.html

Dans options.html

Via content_fixed.js pour le bouton flottant

VÃ©rifier que le bouton flottant reste visible sur nâ€™importe quelle page et ne gÃªne pas les clics (z-index: 999999).

VÃ©rifier quâ€™il ne sâ€™injecte quâ€™une seule fois (pas de duplicata).

âœ… 8. Validation finale

Le robot doit confirmer :

 Tous les boutons existent et portent les bonnes classes.

 Aucun style inline.

 Le fichier buttons.css est chargÃ© partout.

 Tous les Ã©vÃ©nements click produisent une rÃ©ponse visible (toast ou animation).

 Aucune erreur JavaScript dans la console.

 Les boutons se dÃ©sactivent correctement pendant les actions.

 Les Ã©tats visuels (hover, active, focus, disabled) fonctionnent.

 Le bouton flottant sâ€™affiche, change dâ€™Ã©tat, et ouvre/ferme le panneau.
